#ifndef _SQUE_MAKER_RENDER_
#define _SQUE_MAKER_RENDER_

#include <squelib.h>


// Rethinking rendering
/*
    A render pipeline should be modifiable
    A render takes a bunch of steps -> A series of program executions
    Each with different uniforms, data to be passed in,...

    So a render step should:
    - Declare Input Types (meshes, sprites,...)
    - Have a Program to execute -> A program has the uniforms and attributes
    - A way to pass in the values to uniforms
    - Framebuffer -> Where to draw and how

    [] Input/Output Tag system
    The idea is that whatever entity, object, texture,... will have some render tags
    Each tag is used by different render steps, for example, the drawables will be setup
    in structs and a render step will have access to those structs using them after being
    setup. A RenderStep does not modify them but may produce more tags (aka render objects)

    Examples:
    - Geometry Processing Tag: entity processing that genereates transform and drawable object pair
    - Skeleton Forward Rendering Tag: entity processing that takes care of skeleton based animated ojbects
    - Sprite Forward Processing Tag: sets up the tilemap and what do draw where,... 
    - Stream Draw/ Static Draw/... tag: some data requires constant change, some mostly don't
    Then, a render Step just looks at the generated data for drawing (the uniforms) and uses the
    already setup data for rendering (meshes, textures,...)

    A rendering Step might take a look at other tags that are generated by other RenderSteps,
    but these steps are ordered, so one can only take a look at previously generated tags!
*/


// Function calls what to do with each type of value...
// Uniform, Drawable of a type (static, dynamic, alpha,...), Texture,
// How to deal with uniforms? I can equate them to SQUE_Types...
typedef struct RenderValue
{
    char name[16];
    uint32_t id;
    uint32_t type;
    uint64_t data_size;
    void* data;
    uint32_t specific_data_type;
} RenderValue;

typedef void RenderValueFun(const RenderValue& value);
#define RENDER_VALUE_TABLE(ENTRY) // 

enum {
    RENDER_VALUE_TABLE(X3_EXPAND_1)
    RENDER_VALUE_TABLE_NUM_STATES
};

//static RenderValueFun RenderValueFunTable[RENDER_VALUE_TABLE_NUM_STATES] = {RENDER_VALUE_TABLE(X3_EXPAND_2)};
//static const char* RenderValueString[RENDER_VALUE_TABLE_NUM_STATES] = {RENDER_VALUE_TABLE(X3_EXPAND_3)};




// Input Types: Uniform, Vertex Attribute, In
// Output Type: Out,...
// TODO: Join Render_Step and Values -> String and Deal with Function (Float, Vec2, Vec3, Vec4, Matrix4x4,...)
#define RENDER_STEP_TYPE_TABLE(ENTRY) \
        ENTRY(RENDER_STEP_VERTEX, "Vertex") \
        ENTRY(RENDER_STEP_FRAGMENT, "Fragment")

enum {
    RENDER_STEP_TYPE_TABLE(EXPAND_AS_ENUM)
    RENDER_STEP_TYPE_TABLE_NUM_STATES
};

static const char* RenderTypeString[RENDER_STEP_TYPE_TABLE_NUM_STATES] = { RENDER_STEP_TYPE_TABLE(EXPAND_AS_VALUE) };


typedef struct RenderStep
{
    char name[24];
    uint32_t id = -1;
    uint32_t type = -1;

    uint32_t prev_stage_id = -1;
    uint32_t next_stage_id = -1;
    RenderValue shader_in;
    RenderValue shader_out;
    // sque_vec<uint32_t> input_tags;
    sque_vec<RenderValue> input_data;
    sque_vec<RenderValue> output_data;
    
    SQUE_RenderState state;

    const char* shader_source;
} RenderStep;

typedef struct CompiledSteps
{
    sque_vec<uint32_t> step_ids;

    SQUE_Framebuffer framebuffer;
    SQUE_Program program;
} CompiledSteps;

void Render_Init();
void Render_Update(float dt);
void Render_CleanUp();

void Render_CompileSteps();

sque_vec<RenderStep*>& Render_GetSteps();

RenderValue* Render_GetValue(const uint32_t id);

void Render_AddStep(RenderStep* render_step);
RenderStep* Render_GetStep(uint32_t render_step_ref);

#endif