#ifndef _SQUE_MAKER_RENDER_
#define _SQUE_MAKER_RENDER_

#include <squelib.h>


// Rethinking rendering
/*
    A render pipeline should be modifiable
    A render takes a bunch of steps -> A series of program executions
    Each with different uniforms, data to be passed in,...

    So a render step should:
    - Declare Input Types (meshes, sprites,...)
    - Have a Program to execute -> A program has the uniforms and attributes
    - A way to pass in the values to uniforms
    - Framebuffer -> Where to draw and how

    [] Input/Output Tag system
    The idea is that whatever entity, object, texture,... will have some render tags
    Each tag is used by different render steps, for example, the drawables will be setup
    in structs and a render step will have access to those structs using them after being
    setup. A RenderStep does not modify them but may produce more tags (aka render objects)

    Examples:
    - Geometry Processing Tag: entity processing that genereates transform and drawable object pair
    - Skeleton Forward Rendering Tag: entity processing that takes care of skeleton based animated ojbects
    - Sprite Forward Processing Tag: sets up the tilemap and what do draw where,... 
    - Stream Draw/ Static Draw/... tag: some data requires constant change, some mostly don't
    Then, a render Step just looks at the generated data for drawing (the uniforms) and uses the
    already setup data for rendering (meshes, textures,...)

    A rendering Step might take a look at other tags that are generated by other RenderSteps,
    but these steps are ordered, so one can only take a look at previously generated tags!
*/


// Function calls what to do with each type of value...
// Uniform, Drawable of a type (static, dynamic, alpha,...), Texture,
// How to deal with uniforms? I can equate them to SQUE_Types...
typedef struct RenderValue
{
    char name[24] = "RenderValue";
    int id = -1; // Because the id system in imnodes uses only int and there is not proper translation between them...
    uint32_t type = -1;
} RenderValue;

RenderValue Render_GenInputValue();
RenderValue Render_GenOutputValue();

typedef void RenderValueFun(const RenderValue& value);
inline void BadRenderValueFun(const RenderValue& value) 
{
    // Perform Operations related to value for a shader
    // Set Uniform, Perform linkage from a fragment shader to a Vertex shader,...
    // Will have to deal with it in the step of compiling and such.
    // This type of funs should be called inline
}
// Shader Types will have to be put between Vertex and Fragment
#define RENDER_VALUE_TABLE(ENTRY) \
        ENTRY(RENDER_VALUE_VERTEX, "Vertex", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_FRAGMENT, "Fragment", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_FLOAT, "Float", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_INT, "Int", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_TEXTURE, "Texture", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_MATRIX4x4, "Matrix4x4", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_FVEC2, "FVec2", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_FVEC3, "FVec3", BadRenderValueFun) \
        ENTRY(RENDER_VALUE_FVEC4, "FVec4", BadRenderValueFun)

enum {
    RENDER_VALUE_TABLE(X3_EXPAND_1)
    RENDER_VALUE_TABLE_NUM_STATES
};

// Input Types: Uniform, Vertex Attribute, In
// Output Type: Out,...
// TODO: Join Render_Step and Values -> String and Deal with Function (Float, Vec2, Vec3, Vec4, Matrix4x4,...)

static const char* RenderValueString[RENDER_VALUE_TABLE_NUM_STATES] = { RENDER_VALUE_TABLE(X3_EXPAND_2) };
static RenderValueFun* RenderValueFunTable[RENDER_VALUE_TABLE_NUM_STATES] = {RENDER_VALUE_TABLE(X3_EXPAND_3)};



typedef struct RenderStep
{
    char name[24];
    uint32_t id = -1;
    uint32_t type = -1;

    RenderValue shader_in;
    RenderValue shader_out;
    // sque_vec<uint32_t> input_tags;
    sque_vec<RenderValue> input_data;
    sque_vec<RenderValue> output_data;
    
    SQUE_RenderState state;

    const char* shader_source;
} RenderStep;

typedef struct CompiledSteps
{
    sque_vec<uint32_t> step_ids;

    SQUE_Framebuffer framebuffer;
    SQUE_Program program;
} CompiledSteps;

void Render_Init();
void Render_Update(float dt);
void Render_CleanUp();

void Render_CompileSteps();

sque_vec<RenderStep*>& Render_GetSteps();

RenderValue* Render_GetValue(const uint32_t id);

void Render_AddStep(RenderStep* render_step);
RenderStep* Render_GetStep(uint32_t render_step_id);

#endif